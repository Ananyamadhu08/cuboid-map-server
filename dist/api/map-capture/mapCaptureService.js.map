{"version":3,"sources":["../../../src/api/map-capture/mapCaptureService.ts","../../../src/common/models/serviceResponse.ts","../../../src/api/map-capture/mapCaptureRepository.ts"],"sourcesContent":["import { ServiceResponse } from \"@/common/models/serviceResponse\";\nimport type { MapCapture } from \"@prisma/client\";\nimport { StatusCodes } from \"http-status-codes\";\nimport NodeCache from \"node-cache\";\nimport { MapCaptureRepository } from \"./mapCaptureRepository\";\n\nexport class MapCaptureService {\n  private mapCaptureRepository: MapCaptureRepository;\n  private cache: NodeCache;\n\n  constructor(repository: MapCaptureRepository = new MapCaptureRepository()) {\n    this.mapCaptureRepository = repository;\n    this.cache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });\n  }\n\n  async saveCapture(\n    userId: string,\n    data: {\n      title: string;\n      longitude: number;\n      latitude: number;\n      zoom: number;\n      bearing: number;\n      pitch: number;\n      imageUrl: string;\n    },\n  ) {\n    try {\n      const capture = await this.mapCaptureRepository.saveCapture({ userId, ...data });\n      return ServiceResponse.success(\"Map capture saved successfully\", capture, StatusCodes.CREATED);\n    } catch (error) {\n      console.error(\"Error saving map capture:\", error);\n      return ServiceResponse.failure(\"Failed to save map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getAllCaptures() {\n    try {\n      const captures = await this.mapCaptureRepository.findAllCaptures();\n      return ServiceResponse.success(\"Map captures retrieved successfully\", captures, StatusCodes.OK);\n    } catch (error) {\n      console.error(\"Error retrieving map captures:\", error);\n      return ServiceResponse.failure(\"Failed to retrieve map captures.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getAllCapturesByUserId(userId: string, page: number, limit: number) {\n    try {\n      const skip = (page - 1) * limit;\n      const captures = await this.mapCaptureRepository.findAllCapturesByUserId(userId, skip, limit);\n\n      return ServiceResponse.success(\"Captures retrieved successfully\", captures);\n    } catch (error) {\n      return ServiceResponse.failure(\"Failed to retrieve map captures\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getCaptureById(id: string) {\n    try {\n      const capture = await this.mapCaptureRepository.findCaptureById(id);\n      if (!capture) {\n        return ServiceResponse.failure(\"Map capture not found\", null, StatusCodes.NOT_FOUND);\n      }\n      return ServiceResponse.success(\"Map capture retrieved successfully\", capture, StatusCodes.OK);\n    } catch (error) {\n      console.error(\"Error retrieving map capture:\", error);\n      return ServiceResponse.failure(\"Failed to retrieve map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getLatestCaptureByUserId(userId: string) {\n    try {\n      const latestCapture = await this.mapCaptureRepository.findLatestCaptureByUserId(userId);\n\n      if (!latestCapture) {\n        return ServiceResponse.failure(\"No captures found for this user.\", null, StatusCodes.NOT_FOUND);\n      }\n\n      return ServiceResponse.success(\"Latest map capture retrieved successfully\", latestCapture, StatusCodes.OK);\n    } catch (error) {\n      console.log(\"Error retrieving latest map capture:\", error);\n\n      return ServiceResponse.failure(\"Failed to retrieve latest map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getTopCapturedRegions(userId: string) {\n    const cacheKey = `topCapturedRegions_${userId}`;\n    const cachedData = this.cache.get(cacheKey);\n\n    if (cachedData) {\n      return ServiceResponse.success(\"Top captured regions retrieved from cache\", cachedData, StatusCodes.OK);\n    }\n\n    try {\n      // Perform aggregation directly in the database\n      const topRegions = await this.mapCaptureRepository.findTopCapturedRegions(userId);\n\n      if (topRegions.length === 0) {\n        return ServiceResponse.failure(\"No captures found for this user.\", null, StatusCodes.NOT_FOUND);\n      }\n\n      // Cache the result\n      this.cache.set(cacheKey, topRegions);\n\n      return ServiceResponse.success(\"Top captured regions retrieved successfully\", topRegions, StatusCodes.OK);\n    } catch (error) {\n      console.log(\"Error retrieving top captured regions:\", error);\n      return ServiceResponse.failure(\n        \"Failed to retrieve top captured regions.\",\n        null,\n        StatusCodes.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\nexport const mapCaptureService = new MapCaptureService();\n","import { StatusCodes } from \"http-status-codes\";\nimport { z } from \"zod\";\n\nexport class ServiceResponse<T = null> {\n  readonly success: boolean;\n  readonly message: string;\n  readonly responseObject: T;\n  readonly statusCode: number;\n\n  private constructor(success: boolean, message: string, responseObject: T, statusCode: number) {\n    this.success = success;\n    this.message = message;\n    this.responseObject = responseObject;\n    this.statusCode = statusCode;\n  }\n\n  static success<T>(message: string, responseObject: T, statusCode: number = StatusCodes.OK) {\n    return new ServiceResponse(true, message, responseObject, statusCode);\n  }\n\n  static failure<T>(message: string, responseObject: T, statusCode: number = StatusCodes.BAD_REQUEST) {\n    return new ServiceResponse(false, message, responseObject, statusCode);\n  }\n}\n\nexport const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>\n  z.object({\n    success: z.boolean(),\n    message: z.string(),\n    responseObject: dataSchema.optional(),\n    statusCode: z.number(),\n  });\n","import { PrismaClient } from \"@prisma/client\";\n\nconst prisma = new PrismaClient();\n\nexport class MapCaptureRepository {\n  async saveCapture(data: {\n    userId: string;\n    title: string;\n    longitude: number;\n    latitude: number;\n    zoom: number;\n    bearing: number;\n    pitch: number;\n    imageUrl: string;\n  }) {\n    return prisma.mapCapture.create({\n      data,\n    });\n  }\n\n  async findAllCaptures() {\n    return prisma.mapCapture.findMany();\n  }\n\n  async findAllCapturesByUserId(userId: string, skip: number, take: number) {\n    return prisma.mapCapture.findMany({\n      where: { userId },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n      skip,\n      take,\n    });\n  }\n\n  async findCaptureById(id: string) {\n    return prisma.mapCapture.findUnique({\n      where: { id },\n    });\n  }\n\n  async findLatestCaptureByUserId(userId: string) {\n    return prisma.mapCapture.findFirst({\n      where: { userId },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n    });\n  }\n\n  async findTopCapturedRegions(userId: string) {\n    const result = await prisma.mapCapture.groupBy({\n      by: [\"longitude\", \"latitude\", \"title\", \"imageUrl\", \"pitch\", \"zoom\", \"bearing\"],\n      where: { userId },\n      _count: {\n        longitude: true,\n      },\n      orderBy: {\n        _count: {\n          longitude: \"desc\",\n        },\n      },\n      take: 3, // Get top 3 regions\n    });\n\n    return result.map((region) => ({\n      longitude: region.longitude,\n      latitude: region.latitude,\n      frequency: region._count.longitude,\n      title: region.title,\n      imageUrl: region.imageUrl,\n      pitch: region.pitch,\n      zoom: region.zoom,\n      bearing: region.bearing,\n    }));\n  }\n}\n"],"mappings":"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","names":["import_http_status_codes","NodeCache"]}