{"version":3,"sources":["../../../src/api/map-capture/mapCaptureRouter.ts","../../../src/api-docs/openAPIResponseBuilders.ts","../../../src/common/models/serviceResponse.ts","../../../src/common/middleware/authenticateToken.ts","../../../src/common/utils/jwtUtils.ts","../../../src/common/utils/envConfig.ts","../../../src/common/utils/httpHandlers.ts","../../../src/api/map-capture/mapCaptureController.ts","../../../src/api/map-capture/mapCaptureService.ts","../../../src/api/map-capture/mapCaptureRepository.ts","../../../src/api/map-capture/mapCaptureModel.ts"],"sourcesContent":["import { createApiResponse } from \"@/api-docs/openAPIResponseBuilders\";\nimport { authenticateToken } from \"@/common/middleware/authenticateToken\";\nimport { validateRequest } from \"@/common/utils/httpHandlers\";\nimport { OpenAPIRegistry } from \"@asteasolutions/zod-to-openapi\";\nimport express, { type Router } from \"express\";\nimport { mapCaptureController } from \"./mapCaptureController\";\nimport { MapCaptureResponseSchema, MapCaptureSchema } from \"./mapCaptureModel\";\n\nexport const mapCaptureRegistry = new OpenAPIRegistry();\nexport const mapCaptureRouter: Router = express.Router();\n\nmapCaptureRegistry.register(\"MapCapture\", MapCaptureSchema);\n\n// Authenticate all routes in this router\nmapCaptureRouter.use(authenticateToken);\n\n// POST save map capture\nmapCaptureRegistry.registerPath({\n  method: \"post\",\n  path: \"/map-captures\",\n  tags: [\"Map Capture\"],\n  request: {\n    body: {\n      content: {\n        \"application/json\": {\n          schema: MapCaptureSchema,\n        },\n      },\n    },\n  },\n  responses: createApiResponse(MapCaptureResponseSchema, \"Map capture saved successfully\"),\n});\n\n// GET all captures\nmapCaptureRegistry.registerPath({\n  method: \"get\",\n  path: \"/map-captures\",\n  tags: [\"Map Capture\"],\n  responses: createApiResponse(MapCaptureResponseSchema.array(), \"Map captures retrieved successfully\"), // Updated to .array()\n});\n\n// GET latest map capture\nmapCaptureRegistry.registerPath({\n  method: \"get\",\n  path: \"/map-captures/user/latest\",\n  tags: [\"Map Capture\"],\n  responses: createApiResponse(MapCaptureResponseSchema, \"Latest map capture retrieved successfully\"),\n});\n\n// GET top regions\nmapCaptureRegistry.registerPath({\n  method: \"get\",\n  path: \"/map-captures/top-regions\",\n  tags: [\"Map Capture\"],\n  responses: createApiResponse(MapCaptureResponseSchema.array(), \"Top captured regions retrieved successfully\"), // Updated to .array()\n});\n\n// GET specific capture by ID\nmapCaptureRegistry.registerPath({\n  method: \"get\",\n  path: \"/map-captures/{id}\",\n  tags: [\"Map Capture\"],\n  parameters: [\n    {\n      name: \"id\",\n      in: \"path\",\n      required: true,\n      schema: {\n        type: \"string\",\n      },\n    },\n  ],\n  responses: createApiResponse(MapCaptureResponseSchema, \"Map capture retrieved successfully\"),\n});\n\n// POST endpoint to save the map capture\nmapCaptureRouter.post(\"/\", validateRequest(MapCaptureSchema), mapCaptureController.saveCapture);\n\n// GET endpoint to retrieve all map captures of the user\nmapCaptureRouter.get(\"/\", mapCaptureController.getAllUserCaptures);\n\n// GET endpoint to retrieve the latest map capture\nmapCaptureRouter.get(\"/user/latest\", mapCaptureController.getLatestCaptureByUserId);\n\n// GET endpoint to retrieve top regions\nmapCaptureRouter.get(\"/top-regions\", mapCaptureController.getTopCapturedRegions);\n\n// GET endpoint to retrieve a specific map capture by ID\nmapCaptureRouter.get(\"/:id\", mapCaptureController.getCaptureById); // This must be last to avoid conflicts\n","import { StatusCodes } from \"http-status-codes\";\nimport type { z } from \"zod\";\n\nimport { ServiceResponseSchema } from \"@/common/models/serviceResponse\";\n\nexport function createApiResponse(schema: z.ZodTypeAny, description: string, statusCode = StatusCodes.OK) {\n  return {\n    [statusCode]: {\n      description,\n      content: {\n        \"application/json\": {\n          schema: ServiceResponseSchema(schema),\n        },\n      },\n    },\n  };\n}\n","import { StatusCodes } from \"http-status-codes\";\nimport { z } from \"zod\";\n\nexport class ServiceResponse<T = null> {\n  readonly success: boolean;\n  readonly message: string;\n  readonly responseObject: T;\n  readonly statusCode: number;\n\n  private constructor(success: boolean, message: string, responseObject: T, statusCode: number) {\n    this.success = success;\n    this.message = message;\n    this.responseObject = responseObject;\n    this.statusCode = statusCode;\n  }\n\n  static success<T>(message: string, responseObject: T, statusCode: number = StatusCodes.OK) {\n    return new ServiceResponse(true, message, responseObject, statusCode);\n  }\n\n  static failure<T>(message: string, responseObject: T, statusCode: number = StatusCodes.BAD_REQUEST) {\n    return new ServiceResponse(false, message, responseObject, statusCode);\n  }\n}\n\nexport const ServiceResponseSchema = <T extends z.ZodTypeAny>(dataSchema: T) =>\n  z.object({\n    success: z.boolean(),\n    message: z.string(),\n    responseObject: dataSchema.optional(),\n    statusCode: z.number(),\n  });\n","import type { User } from \"@prisma/client\";\nimport type { NextFunction, Response } from \"express\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { JsonWebTokenError, TokenExpiredError } from \"jsonwebtoken\";\nimport { verifyToken } from \"../utils/jwtUtils\";\nimport { ServiceResponse } from \"./../models/serviceResponse\";\nimport type { AuthenticatedRequest } from \"./../types\";\n\nexport const authenticateToken = (req: AuthenticatedRequest, res: Response, next: NextFunction) => {\n  const authHeader = req.headers.authorization;\n\n  if (!authHeader) {\n    return res\n      .status(StatusCodes.UNAUTHORIZED)\n      .json(ServiceResponse.failure(\"Access denied. No token provided.\", null, StatusCodes.UNAUTHORIZED));\n  }\n\n  const token = authHeader.split(\" \")[1];\n\n  try {\n    const decoded = verifyToken(token) as { userId: string; iat: number; exp: number };\n    req.user = { id: decoded.userId } as User;\n\n    console.log(\"Decoded user from token:\", decoded);\n    console.log(\"User ID:\", req.user.id);\n\n    next();\n  } catch (err) {\n    if (err instanceof TokenExpiredError) {\n      console.error(\"Token expired:\", err.message);\n      return res\n        .status(StatusCodes.UNAUTHORIZED)\n        .json(ServiceResponse.failure(\"Token expired.\", null, StatusCodes.UNAUTHORIZED));\n    } else if (err instanceof JsonWebTokenError) {\n      console.error(\"Invalid token:\", err.message);\n      return res\n        .status(StatusCodes.FORBIDDEN)\n        .json(ServiceResponse.failure(\"Invalid token.\", null, StatusCodes.FORBIDDEN));\n    } else {\n      console.error(\"Token verification failed:\", err);\n      return res\n        .status(StatusCodes.INTERNAL_SERVER_ERROR)\n        .json(ServiceResponse.failure(\"Token verification failed.\", null, StatusCodes.INTERNAL_SERVER_ERROR));\n    }\n  }\n};\n","import jwt, { JsonWebTokenError, TokenExpiredError } from \"jsonwebtoken\";\nimport { env } from \"./envConfig\";\n\nconst secret = env.JWT_SECRET;\n\nexport function generateToken(userId: string): string {\n  return jwt.sign({ userId }, secret, { expiresIn: \"1d\" }); // Access token valid for 1 day\n}\n\nexport function generateRefreshToken(userId: string): string {\n  return jwt.sign({ userId }, secret, { expiresIn: \"7d\" }); // Refresh token valid for 7 days\n}\n\nexport function verifyToken(token: string, type: \"access\" | \"refresh\" = \"access\"): any {\n  try {\n    return jwt.verify(token, secret);\n  } catch (error) {\n    if (error instanceof TokenExpiredError) {\n      throw new TokenExpiredError(\"Token expired\", error.expiredAt);\n    } else if (error instanceof JsonWebTokenError) {\n      throw new JsonWebTokenError(\"Invalid token\");\n    } else {\n      throw new Error(\"Token verification failed\");\n    }\n  }\n}\n","import dotenv from \"dotenv\";\nimport { cleanEnv, host, num, port, str, testOnly } from \"envalid\";\n\ndotenv.config();\n\nexport const env = cleanEnv(process.env, {\n  NODE_ENV: str({ devDefault: testOnly(\"test\"), choices: [\"development\", \"production\", \"test\"] }),\n  HOST: host({ devDefault: testOnly(\"localhost\") }),\n  PORT: port({ devDefault: testOnly(3000) }),\n  CORS_ORIGIN: str({ devDefault: testOnly(\"http://localhost:5173\") }),\n  COMMON_RATE_LIMIT_MAX_REQUESTS: num({ devDefault: testOnly(1000) }),\n  COMMON_RATE_LIMIT_WINDOW_MS: num({ devDefault: testOnly(1000) }),\n  DATABASE_URL: str(),\n  JWT_SECRET: str(),\n});\n","import type { NextFunction, Request, Response } from \"express\";\nimport { StatusCodes } from \"http-status-codes\";\nimport type { ZodSchema } from \"zod\";\n\nimport { ServiceResponse } from \"@/common/models/serviceResponse\";\n\nexport const handleServiceResponse = (serviceResponse: ServiceResponse<any>, response: Response) => {\n  return response.status(serviceResponse.statusCode).send(serviceResponse);\n};\n\nexport const validateRequest = (schema: ZodSchema) => (req: Request, res: Response, next: NextFunction) => {\n  // Validate using safeParse\n  const result = schema.safeParse(req.body);\n\n  if (!result.success) {\n    const zodError = result.error;\n\n    // Build a more detailed error message\n    const errorMessage = `Invalid input: ${zodError.errors.map((e) => `${e.path.join(\".\")} - ${e.message}`).join(\", \")}`;\n    const statusCode = StatusCodes.BAD_REQUEST;\n\n    const serviceResponse = ServiceResponse.failure(errorMessage, null, statusCode);\n    return handleServiceResponse(serviceResponse, res);\n  }\n\n  next();\n};\n","import { ServiceResponse } from \"@/common/models/serviceResponse\";\nimport { handleServiceResponse } from \"@/common/utils/httpHandlers\";\nimport type { User } from \"@prisma/client\";\nimport type { Request, Response } from \"express\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { mapCaptureService } from \"./mapCaptureService\";\n\ninterface MapCaptureRequest extends Request {\n  user?: User;\n}\n\nexport interface LatestMapCaptureRequest extends Request {\n  user?: User;\n}\n\nclass MapCaptureController {\n  async saveCapture(req: MapCaptureRequest, res: Response) {\n    const userId = req.user?.id as string;\n\n    if (!userId) {\n      return ServiceResponse.failure(\"User ID is missing from the request.\", null, StatusCodes.BAD_REQUEST);\n    }\n\n    const { title, longitude, latitude, zoom, bearing, pitch, imageUrl } = req.body;\n\n    if (!title || !longitude || !latitude || !imageUrl) {\n      return ServiceResponse.failure(\"Missing required fields in the request.\", null, StatusCodes.BAD_REQUEST);\n    }\n\n    const serviceResponse = await mapCaptureService.saveCapture(userId, {\n      title,\n      longitude,\n      latitude,\n      zoom,\n      bearing,\n      pitch,\n      imageUrl,\n    });\n\n    return handleServiceResponse(serviceResponse, res);\n  }\n\n  async getAllUserCaptures(req: MapCaptureRequest, res: Response) {\n    const userId = req.user?.id as string;\n\n    if (!userId) {\n      return ServiceResponse.failure(\"User ID is missing from the request.\", null, StatusCodes.BAD_REQUEST);\n    }\n\n    const page = Number.parseInt(req.query.page as string, 10) || 1;\n    const limit = Number.parseInt(req.query.limit as string, 10) || 10;\n\n    const serviceResponse = await mapCaptureService.getAllCapturesByUserId(userId, page, limit);\n\n    return handleServiceResponse(serviceResponse, res);\n  }\n\n  async getCaptureById(req: Request, res: Response) {\n    const { id } = req.params;\n\n    const serviceResponse = await mapCaptureService.getCaptureById(id);\n\n    return handleServiceResponse(serviceResponse, res);\n  }\n\n  async getLatestCaptureByUserId(req: LatestMapCaptureRequest, res: Response) {\n    const userId = req.user?.id as string;\n\n    if (!userId) {\n      return ServiceResponse.failure(\"User ID is missing from the request.\", null, StatusCodes.BAD_REQUEST);\n    }\n\n    const serviceResponse = await mapCaptureService.getLatestCaptureByUserId(userId);\n    return handleServiceResponse(serviceResponse, res);\n  }\n\n  async getTopCapturedRegions(req: MapCaptureRequest, res: Response) {\n    const userId = req.user?.id as string;\n\n    if (!userId) {\n      return ServiceResponse.failure(\"User ID is missing from the request.\", null, StatusCodes.BAD_REQUEST);\n    }\n\n    const serviceResponse = await mapCaptureService.getTopCapturedRegions(userId);\n    return handleServiceResponse(serviceResponse, res);\n  }\n}\n\nexport const mapCaptureController = new MapCaptureController();\n","import { ServiceResponse } from \"@/common/models/serviceResponse\";\nimport type { MapCapture } from \"@prisma/client\";\nimport { StatusCodes } from \"http-status-codes\";\nimport NodeCache from \"node-cache\";\nimport { MapCaptureRepository } from \"./mapCaptureRepository\";\n\nexport class MapCaptureService {\n  private mapCaptureRepository: MapCaptureRepository;\n  private cache: NodeCache;\n\n  constructor(repository: MapCaptureRepository = new MapCaptureRepository()) {\n    this.mapCaptureRepository = repository;\n    this.cache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });\n  }\n\n  async saveCapture(\n    userId: string,\n    data: {\n      title: string;\n      longitude: number;\n      latitude: number;\n      zoom: number;\n      bearing: number;\n      pitch: number;\n      imageUrl: string;\n    },\n  ) {\n    try {\n      const capture = await this.mapCaptureRepository.saveCapture({ userId, ...data });\n      return ServiceResponse.success(\"Map capture saved successfully\", capture, StatusCodes.CREATED);\n    } catch (error) {\n      console.error(\"Error saving map capture:\", error);\n      return ServiceResponse.failure(\"Failed to save map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getAllCaptures() {\n    try {\n      const captures = await this.mapCaptureRepository.findAllCaptures();\n      return ServiceResponse.success(\"Map captures retrieved successfully\", captures, StatusCodes.OK);\n    } catch (error) {\n      console.error(\"Error retrieving map captures:\", error);\n      return ServiceResponse.failure(\"Failed to retrieve map captures.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getAllCapturesByUserId(userId: string, page: number, limit: number) {\n    try {\n      const skip = (page - 1) * limit;\n      const captures = await this.mapCaptureRepository.findAllCapturesByUserId(userId, skip, limit);\n\n      return ServiceResponse.success(\"Captures retrieved successfully\", captures);\n    } catch (error) {\n      return ServiceResponse.failure(\"Failed to retrieve map captures\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getCaptureById(id: string) {\n    try {\n      const capture = await this.mapCaptureRepository.findCaptureById(id);\n      if (!capture) {\n        return ServiceResponse.failure(\"Map capture not found\", null, StatusCodes.NOT_FOUND);\n      }\n      return ServiceResponse.success(\"Map capture retrieved successfully\", capture, StatusCodes.OK);\n    } catch (error) {\n      console.error(\"Error retrieving map capture:\", error);\n      return ServiceResponse.failure(\"Failed to retrieve map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getLatestCaptureByUserId(userId: string) {\n    try {\n      const latestCapture = await this.mapCaptureRepository.findLatestCaptureByUserId(userId);\n\n      if (!latestCapture) {\n        return ServiceResponse.failure(\"No captures found for this user.\", null, StatusCodes.NOT_FOUND);\n      }\n\n      return ServiceResponse.success(\"Latest map capture retrieved successfully\", latestCapture, StatusCodes.OK);\n    } catch (error) {\n      console.log(\"Error retrieving latest map capture:\", error);\n\n      return ServiceResponse.failure(\"Failed to retrieve latest map capture.\", null, StatusCodes.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  async getTopCapturedRegions(userId: string) {\n    const cacheKey = `topCapturedRegions_${userId}`;\n    const cachedData = this.cache.get(cacheKey);\n\n    if (cachedData) {\n      return ServiceResponse.success(\"Top captured regions retrieved from cache\", cachedData, StatusCodes.OK);\n    }\n\n    try {\n      // Perform aggregation directly in the database\n      const topRegions = await this.mapCaptureRepository.findTopCapturedRegions(userId);\n\n      if (topRegions.length === 0) {\n        return ServiceResponse.failure(\"No captures found for this user.\", null, StatusCodes.NOT_FOUND);\n      }\n\n      // Cache the result\n      this.cache.set(cacheKey, topRegions);\n\n      return ServiceResponse.success(\"Top captured regions retrieved successfully\", topRegions, StatusCodes.OK);\n    } catch (error) {\n      console.log(\"Error retrieving top captured regions:\", error);\n      return ServiceResponse.failure(\n        \"Failed to retrieve top captured regions.\",\n        null,\n        StatusCodes.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\nexport const mapCaptureService = new MapCaptureService();\n","import { PrismaClient } from \"@prisma/client\";\n\nconst prisma = new PrismaClient();\n\nexport class MapCaptureRepository {\n  async saveCapture(data: {\n    userId: string;\n    title: string;\n    longitude: number;\n    latitude: number;\n    zoom: number;\n    bearing: number;\n    pitch: number;\n    imageUrl: string;\n  }) {\n    return prisma.mapCapture.create({\n      data,\n    });\n  }\n\n  async findAllCaptures() {\n    return prisma.mapCapture.findMany();\n  }\n\n  async findAllCapturesByUserId(userId: string, skip: number, take: number) {\n    return prisma.mapCapture.findMany({\n      where: { userId },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n      skip,\n      take,\n    });\n  }\n\n  async findCaptureById(id: string) {\n    return prisma.mapCapture.findUnique({\n      where: { id },\n    });\n  }\n\n  async findLatestCaptureByUserId(userId: string) {\n    return prisma.mapCapture.findFirst({\n      where: { userId },\n      orderBy: {\n        createdAt: \"desc\",\n      },\n    });\n  }\n\n  async findTopCapturedRegions(userId: string) {\n    const result = await prisma.mapCapture.groupBy({\n      by: [\"longitude\", \"latitude\", \"title\", \"imageUrl\", \"pitch\", \"zoom\", \"bearing\"],\n      where: { userId },\n      _count: {\n        longitude: true,\n      },\n      orderBy: {\n        _count: {\n          longitude: \"desc\",\n        },\n      },\n      take: 3, // Get top 3 regions\n    });\n\n    return result.map((region) => ({\n      longitude: region.longitude,\n      latitude: region.latitude,\n      frequency: region._count.longitude,\n      title: region.title,\n      imageUrl: region.imageUrl,\n      pitch: region.pitch,\n      zoom: region.zoom,\n      bearing: region.bearing,\n    }));\n  }\n}\n","import { extendZodWithOpenApi } from \"@asteasolutions/zod-to-openapi\";\nimport { z } from \"zod\";\n\nextendZodWithOpenApi(z);\n\nexport type MapCapture = z.infer<typeof MapCaptureSchema>;\n\nexport const MapCaptureSchema = z\n  .object({\n    title: z.string().min(1, \"Title is required\"),\n    longitude: z.number(),\n    latitude: z.number(),\n    zoom: z.number(),\n    bearing: z.number(),\n    pitch: z.number(),\n    imageUrl: z.string().url(),\n  })\n  .openapi(\"MapCaptureRequest\");\n\nexport const MapCaptureResponseSchema = z\n  .object({\n    id: z.string().openapi({ description: \"The unique identifier of the map capture\" }),\n    userId: z.string().openapi({ description: \"The ID of the user who created the capture\" }),\n    title: z.string().openapi({ description: \"The title of the map capture\" }),\n    longitude: z.number(),\n    latitude: z.number(),\n    zoom: z.number(),\n    bearing: z.number(),\n    pitch: z.number(),\n    imageUrl: z.string().url(),\n    createdAt: z.string().openapi({ description: \"Timestamp of when the capture was created\" }),\n  })\n  .openapi(\"MapCaptureResponse\");\n"],"mappings":"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","names":["import_http_status_codes","import_http_status_codes","import_jsonwebtoken","dotenv","jwt","import_http_status_codes","import_zod_to_openapi","import_http_status_codes","import_http_status_codes","NodeCache","import_zod","express"]}